

def visit_recursively(start, goal, graph, visited):
    """Recursive function for the traversal of graph"""
    if start == goal:
        return True
    visited.add(start)
    has_path = False
    for neighbor in graph[start]:
        if neighbor not in visited:
            has_path = has_path or visit_recursively(neighbor, goal, graph, visited)
    return has_path

def has_path(u,v,graph):
    """True if there is a path from u to v in the graph"""
    if v not in graph or u not in graph:
        return False
    visited = set()
    return visit_recursively(u,v,graph,visited)

def get_acyclic_graph_with_weights(graph):
    """Return an acyclic graph generated by adding the edges of max weight when they do not create a cycle"""
    res_graph = {u:{} for u in graph}
    all_edges = sorted([(weight, (u,v)) for u,neighbors in graph.items() for v,weight in neighbors.items()], reverse = True)
    for (weight, (u,v)) in all_edges:
        if not has_path(v,u,res_graph):
            res_graph[u][v] = weight
    return res_graph

def get_sink(graph):
    """Return the sink of the graph"""
    nb_out_edges, node = min([(len(v), n) for n,v in graph.items()])
    if nb_out_edges > 0:
        raise ValueError("The graph does not have a sink, so it is not acyclic")
    return node

def get_order_from_acyclic_graph(graph):
    """Return a sequence from an acyclic graph generated by the previous algorithm"""
    sequence = []
    while len(graph) > 0:
        sink = get_sink(graph)
        graph.pop(sink)
        for u in graph:
            graph[u].pop(sink,None)
        sequence.append(sink)
    return sequence[::-1]

def generate_sequence_from_weighted_heuristic(graph):
    """Generate a sequence from a tournament graph using the weight heuristic"""
    acyclic_graph = get_acyclic_graph_with_weights(graph)
    return get_order_from_acyclic_graph(acyclic_graph)

if __name__ == '__main__':
    graph = {0:{1:0.9, 2:0.91, 4:0.61},
             1:{2:0.82, 3:0.69, 4:0.81},
             2:{3:0.75},
             3:{4:0.65},
             4:{2:0.7}}
    print(generate_sequence_from_weighted_heuristic(graph))
